// Generated by PeakRDL-cheader - A free and open-source header generator
//  https://github.com/SystemRDL/PeakRDL-cheader

#ifndef CSR_H
#define CSR_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <assert.h>

// Mem - uberclock::imem
typedef struct __attribute__ ((__packed__)) {
    uint32_t mem[8192];
} uberclock__imem_t;

// Mem - uberclock::dmem
typedef struct __attribute__ ((__packed__)) {
    uint32_t mem[8192];
} uberclock__dmem_t;

// Reg - csr::uart::rx
#define CSR__UART__RX__DATA_bm 0xff
#define CSR__UART__RX__DATA_bp 0
#define CSR__UART__RX__DATA_bw 8
#define CSR__UART__RX__DATA_reset 0x0
#define CSR__UART__RX__OFLOW_bm 0x40000000
#define CSR__UART__RX__OFLOW_bp 30
#define CSR__UART__RX__OFLOW_bw 1
#define CSR__UART__RX__OFLOW_reset 0x0
#define CSR__UART__RX__VALID_bm 0x80000000
#define CSR__UART__RX__VALID_bp 31
#define CSR__UART__RX__VALID_bw 1
#define CSR__UART__RX__VALID_reset 0x0
typedef union {
    struct __attribute__ ((__packed__)) {
        uint32_t data :8;
        uint32_t :22;
        uint32_t oflow :1;
        uint32_t valid :1;
    } f;
    uint32_t w;
} csr__uart__rx_t;

// Reg - csr::uart::rx_trigger_read_2925067f
#define CSR__UART__RX_TRIGGER_READ_2925067F__READ_bm 0x1
#define CSR__UART__RX_TRIGGER_READ_2925067F__READ_bp 0
#define CSR__UART__RX_TRIGGER_READ_2925067F__READ_bw 1
#define CSR__UART__RX_TRIGGER_READ_2925067F__READ_reset 0x0
typedef union {
    struct __attribute__ ((__packed__)) {
        uint32_t read :1;
        uint32_t :31;
    } f;
    uint32_t w;
} csr__uart__rx_trigger_read_2925067f_t;

// Reg - csr::uart::tx
#define CSR__UART__TX__DATA_bm 0xff
#define CSR__UART__TX__DATA_bp 0
#define CSR__UART__TX__DATA_bw 8
#define CSR__UART__TX__DATA_reset 0x0
#define CSR__UART__TX__BUSY_bm 0x80000000
#define CSR__UART__TX__BUSY_bp 31
#define CSR__UART__TX__BUSY_bw 1
#define CSR__UART__TX__BUSY_reset 0x0
typedef union {
    struct __attribute__ ((__packed__)) {
        uint32_t data :8;
        uint32_t :23;
        uint32_t busy :1;
    } f;
    uint32_t w;
} csr__uart__tx_t;

// Reg - csr::uart::tx_trigger_write_d2a2fe0e
#define CSR__UART__TX_TRIGGER_WRITE_D2A2FE0E__WRITE_bm 0x1
#define CSR__UART__TX_TRIGGER_WRITE_D2A2FE0E__WRITE_bp 0
#define CSR__UART__TX_TRIGGER_WRITE_D2A2FE0E__WRITE_bw 1
#define CSR__UART__TX_TRIGGER_WRITE_D2A2FE0E__WRITE_reset 0x0
typedef union {
    struct __attribute__ ((__packed__)) {
        uint32_t write :1;
        uint32_t :31;
    } f;
    uint32_t w;
} csr__uart__tx_trigger_write_d2a2fe0e_t;

// Regfile - csr::uart
typedef struct __attribute__ ((__packed__)) {
    csr__uart__rx_t rx;
    csr__uart__rx_trigger_read_2925067f_t rx_trigger;
    csr__uart__tx_t tx;
    csr__uart__tx_trigger_write_d2a2fe0e_t tx_trigger;
} csr__uart_t;

// Reg - csr::gpio
#define CSR__GPIO__KEY1_bm 0x1
#define CSR__GPIO__KEY1_bp 0
#define CSR__GPIO__KEY1_bw 1
#define CSR__GPIO__KEY1_reset 0x0
#define CSR__GPIO__KEY2_bm 0x2
#define CSR__GPIO__KEY2_bp 1
#define CSR__GPIO__KEY2_bw 1
#define CSR__GPIO__KEY2_reset 0x0
#define CSR__GPIO__LED1_bm 0x100
#define CSR__GPIO__LED1_bp 8
#define CSR__GPIO__LED1_bw 1
#define CSR__GPIO__LED1_reset 0x0
#define CSR__GPIO__LED2_bm 0x200
#define CSR__GPIO__LED2_bp 9
#define CSR__GPIO__LED2_bw 1
#define CSR__GPIO__LED2_reset 0x0
typedef union {
    struct __attribute__ ((__packed__)) {
        uint32_t key1 :1;
        uint32_t key2 :1;
        uint32_t :6;
        uint32_t led1 :1;
        uint32_t led2 :1;
        uint32_t :22;
    } f;
    uint32_t w;
} csr__gpio_t;

// Reg - csr::hw_id
#define CSR__HW_ID__PRODUCT_bm 0xffff
#define CSR__HW_ID__PRODUCT_bp 0
#define CSR__HW_ID__PRODUCT_bw 16
#define CSR__HW_ID__PRODUCT_reset 0xc10c
#define CSR__HW_ID__VENDOR_bm 0xffff0000
#define CSR__HW_ID__VENDOR_bp 16
#define CSR__HW_ID__VENDOR_bw 16
#define CSR__HW_ID__VENDOR_reset 0xccae
typedef union {
    struct __attribute__ ((__packed__)) {
        uint32_t PRODUCT :16;
        uint32_t VENDOR :16;
    } f;
    uint32_t w;
} csr__hw_id_t;

// Reg - csr::hw_version
#define CSR__HW_VERSION__PATCH_bm 0xffff
#define CSR__HW_VERSION__PATCH_bp 0
#define CSR__HW_VERSION__PATCH_bw 16
#define CSR__HW_VERSION__PATCH_reset 0x0
#define CSR__HW_VERSION__MINOR_bm 0xff0000
#define CSR__HW_VERSION__MINOR_bp 16
#define CSR__HW_VERSION__MINOR_bw 8
#define CSR__HW_VERSION__MINOR_reset 0x1
#define CSR__HW_VERSION__MAJOR_bm 0xff000000
#define CSR__HW_VERSION__MAJOR_bp 24
#define CSR__HW_VERSION__MAJOR_bw 8
#define CSR__HW_VERSION__MAJOR_reset 0x0
typedef union {
    struct __attribute__ ((__packed__)) {
        uint32_t PATCH :16;
        uint32_t MINOR :8;
        uint32_t MAJOR :8;
    } f;
    uint32_t w;
} csr__hw_version_t;

// Addrmap - csr
typedef struct __attribute__ ((__packed__)) {
    csr__uart_t uart;
    csr__gpio_t gpio;
    csr__hw_id_t hw_id;
    csr__hw_version_t hw_version;
} csr_t;

// Addrmap - uberclock
typedef struct __attribute__ ((__packed__)) {
    uberclock__imem_t imem;
    uint8_t RESERVED_8000_fffffff[0xfff8000];
    uberclock__dmem_t dmem;
    uint8_t RESERVED_10008000_1fffffff[0xfff8000];
    csr_t csr;
} uberclock_t;


static_assert(sizeof(uberclock_t) == 0x2000001c, "Packing error");

#ifdef __cplusplus
}
#endif

#endif /* CSR_H */

// Generated by PeakRDL-cheader - A free and open-source header generator
//  https://github.com/SystemRDL/PeakRDL-cheader

#ifndef CSR_H
#define CSR_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <assert.h>

// Mem - uberclock::imem
typedef struct __attribute__ ((__packed__)) {
    uint32_t mem[8192];
} uberclock__imem_t;

// Mem - uberclock::dmem
typedef struct __attribute__ ((__packed__)) {
    uint32_t mem[8192];
} uberclock__dmem_t;

// Reg - csr::uart::rx
#define CSR__UART__RX__DATA_bm 0xff
#define CSR__UART__RX__DATA_bp 0
#define CSR__UART__RX__DATA_bw 8
#define CSR__UART__RX__DATA_reset 0x0
#define CSR__UART__RX__OFLOW_bm 0x40000000
#define CSR__UART__RX__OFLOW_bp 30
#define CSR__UART__RX__OFLOW_bw 1
#define CSR__UART__RX__OFLOW_reset 0x0
#define CSR__UART__RX__VALID_bm 0x80000000
#define CSR__UART__RX__VALID_bp 31
#define CSR__UART__RX__VALID_bw 1
#define CSR__UART__RX__VALID_reset 0x0
typedef union {
    struct __attribute__ ((__packed__)) {
        uint32_t data :8;
        uint32_t :22;
        uint32_t oflow :1;
        uint32_t valid :1;
    } f;
    uint32_t w;
} csr__uart__rx_t;

// Reg - csr::uart::rx_trigger_read_2925067f
#define CSR__UART__RX_TRIGGER_READ_2925067F__READ_bm 0x1
#define CSR__UART__RX_TRIGGER_READ_2925067F__READ_bp 0
#define CSR__UART__RX_TRIGGER_READ_2925067F__READ_bw 1
#define CSR__UART__RX_TRIGGER_READ_2925067F__READ_reset 0x0
typedef union {
    struct __attribute__ ((__packed__)) {
        uint32_t read :1;
        uint32_t :31;
    } f;
    uint32_t w;
} csr__uart__rx_trigger_read_2925067f_t;

// Reg - csr::uart::tx
#define CSR__UART__TX__DATA_bm 0xff
#define CSR__UART__TX__DATA_bp 0
#define CSR__UART__TX__DATA_bw 8
#define CSR__UART__TX__DATA_reset 0x0
#define CSR__UART__TX__BUSY_bm 0x80000000
#define CSR__UART__TX__BUSY_bp 31
#define CSR__UART__TX__BUSY_bw 1
#define CSR__UART__TX__BUSY_reset 0x0
typedef union {
    struct __attribute__ ((__packed__)) {
        uint32_t data :8;
        uint32_t :23;
        uint32_t busy :1;
    } f;
    uint32_t w;
} csr__uart__tx_t;

// Reg - csr::uart::tx_trigger_write_d2a2fe0e
#define CSR__UART__TX_TRIGGER_WRITE_D2A2FE0E__WRITE_bm 0x1
#define CSR__UART__TX_TRIGGER_WRITE_D2A2FE0E__WRITE_bp 0
#define CSR__UART__TX_TRIGGER_WRITE_D2A2FE0E__WRITE_bw 1
#define CSR__UART__TX_TRIGGER_WRITE_D2A2FE0E__WRITE_reset 0x0
typedef union {
    struct __attribute__ ((__packed__)) {
        uint32_t write :1;
        uint32_t :31;
    } f;
    uint32_t w;
} csr__uart__tx_trigger_write_d2a2fe0e_t;

// Regfile - csr::uart
typedef struct __attribute__ ((__packed__)) {
    csr__uart__rx_t rx;
    csr__uart__rx_trigger_read_2925067f_t rx_trigger;
    csr__uart__tx_t tx;
    csr__uart__tx_trigger_write_d2a2fe0e_t tx_trigger;
} csr__uart_t;

// Reg - csr::gpio
#define CSR__GPIO__KEY1_bm 0x1
#define CSR__GPIO__KEY1_bp 0
#define CSR__GPIO__KEY1_bw 1
#define CSR__GPIO__KEY1_reset 0x0
#define CSR__GPIO__KEY2_bm 0x2
#define CSR__GPIO__KEY2_bp 1
#define CSR__GPIO__KEY2_bw 1
#define CSR__GPIO__KEY2_reset 0x0
#define CSR__GPIO__LED1_bm 0x100
#define CSR__GPIO__LED1_bp 8
#define CSR__GPIO__LED1_bw 1
#define CSR__GPIO__LED1_reset 0x0
#define CSR__GPIO__LED2_bm 0x200
#define CSR__GPIO__LED2_bp 9
#define CSR__GPIO__LED2_bw 1
#define CSR__GPIO__LED2_reset 0x0
typedef union {
    struct __attribute__ ((__packed__)) {
        uint32_t key1 :1;
        uint32_t key2 :1;
        uint32_t :6;
        uint32_t led1 :1;
        uint32_t led2 :1;
        uint32_t :22;
    } f;
    uint32_t w;
} csr__gpio_t;

// Reg - csr::hw_id
#define CSR__HW_ID__PRODUCT_bm 0xffff
#define CSR__HW_ID__PRODUCT_bp 0
#define CSR__HW_ID__PRODUCT_bw 16
#define CSR__HW_ID__PRODUCT_reset 0xc10c
#define CSR__HW_ID__VENDOR_bm 0xffff0000
#define CSR__HW_ID__VENDOR_bp 16
#define CSR__HW_ID__VENDOR_bw 16
#define CSR__HW_ID__VENDOR_reset 0xccae
typedef union {
    struct __attribute__ ((__packed__)) {
        uint32_t PRODUCT :16;
        uint32_t VENDOR :16;
    } f;
    uint32_t w;
} csr__hw_id_t;

// Reg - csr::adc
#define CSR__ADC__CH2_bm 0xfff
#define CSR__ADC__CH2_bp 0
#define CSR__ADC__CH2_bw 12
#define CSR__ADC__CH2_reset 0x0
#define CSR__ADC__CH1_bm 0xfff0000
#define CSR__ADC__CH1_bp 16
#define CSR__ADC__CH1_bw 12
#define CSR__ADC__CH1_reset 0x0
#define CSR__ADC__DONE_bm 0x40000000
#define CSR__ADC__DONE_bp 30
#define CSR__ADC__DONE_bw 1
#define CSR__ADC__DONE_reset 0x0
#define CSR__ADC__START_bm 0x80000000
#define CSR__ADC__START_bp 31
#define CSR__ADC__START_bw 1
#define CSR__ADC__START_reset 0x0
typedef union {
    struct __attribute__ ((__packed__)) {
        uint32_t ch2 :12;
        uint32_t :4;
        uint32_t ch1 :12;
        uint32_t :2;
        uint32_t done :1;
        uint32_t start :1;
    } f;
    uint32_t w;
} csr__adc_t;

// Reg - csr::dac
#define CSR__DAC__CH2_bm 0x3fff
#define CSR__DAC__CH2_bp 0
#define CSR__DAC__CH2_bw 14
#define CSR__DAC__CH2_reset 0x0
#define CSR__DAC__CH1_bm 0x3fff0000
#define CSR__DAC__CH1_bp 16
#define CSR__DAC__CH1_bw 14
#define CSR__DAC__CH1_reset 0x0
typedef union {
    struct __attribute__ ((__packed__)) {
        uint32_t ch2 :14;
        uint32_t :2;
        uint32_t ch1 :14;
        uint32_t :2;
    } f;
    uint32_t w;
} csr__dac_t;

// Reg - csr::dac_mem_ctrl
#define CSR__DAC_MEM_CTRL__LEN_bm 0x7ff
#define CSR__DAC_MEM_CTRL__LEN_bp 0
#define CSR__DAC_MEM_CTRL__LEN_bw 11
#define CSR__DAC_MEM_CTRL__LEN_reset 0x0
#define CSR__DAC_MEM_CTRL__EN_bm 0x80000000
#define CSR__DAC_MEM_CTRL__EN_bp 31
#define CSR__DAC_MEM_CTRL__EN_bw 1
#define CSR__DAC_MEM_CTRL__EN_reset 0x0
typedef union {
    struct __attribute__ ((__packed__)) {
        uint32_t len :11;
        uint32_t :20;
        uint32_t en :1;
    } f;
    uint32_t w;
} csr__dac_mem_ctrl_t;

// Reg - csr::dac_freq
#define CSR__DAC_FREQ__STEP_bm 0xffffffff
#define CSR__DAC_FREQ__STEP_bp 0
#define CSR__DAC_FREQ__STEP_bw 32
#define CSR__DAC_FREQ__STEP_reset 0x0
typedef union {
    struct __attribute__ ((__packed__)) {
        uint32_t step :32;
    } f;
    uint32_t w;
} csr__dac_freq_t;

// Reg - csr::hw_version
#define CSR__HW_VERSION__PATCH_bm 0xffff
#define CSR__HW_VERSION__PATCH_bp 0
#define CSR__HW_VERSION__PATCH_bw 16
#define CSR__HW_VERSION__PATCH_reset 0x0
#define CSR__HW_VERSION__MINOR_bm 0xff0000
#define CSR__HW_VERSION__MINOR_bp 16
#define CSR__HW_VERSION__MINOR_bw 8
#define CSR__HW_VERSION__MINOR_reset 0x1
#define CSR__HW_VERSION__MAJOR_bm 0xff000000
#define CSR__HW_VERSION__MAJOR_bp 24
#define CSR__HW_VERSION__MAJOR_bw 8
#define CSR__HW_VERSION__MAJOR_reset 0x0
typedef union {
    struct __attribute__ ((__packed__)) {
        uint32_t PATCH :16;
        uint32_t MINOR :8;
        uint32_t MAJOR :8;
    } f;
    uint32_t w;
} csr__hw_version_t;

// Mem - csr::dac_mem
typedef struct __attribute__ ((__packed__)) {
    uint32_t mem[2048];
} csr__dac_mem_t;

// Addrmap - csr
typedef struct __attribute__ ((__packed__)) {
    csr__uart_t uart;
    csr__gpio_t gpio;
    csr__hw_id_t hw_id;
    csr__adc_t adc;
    csr__dac_t dac;
    csr__dac_mem_ctrl_t dac_mem_ctrl;
    csr__dac_freq_t dac_freq;
    csr__hw_version_t hw_version;
    uint8_t RESERVED_2c_1fff[0x1fd4];
    csr__dac_mem_t dac_mem;
} csr_t;

// Addrmap - uberclock
typedef struct __attribute__ ((__packed__)) {
    uberclock__imem_t imem;
    uint8_t RESERVED_8000_fffffff[0xfff8000];
    uberclock__dmem_t dmem;
    uint8_t RESERVED_10008000_1fffffff[0xfff8000];
    csr_t csr;
} uberclock_t;


static_assert(sizeof(uberclock_t) == 0x20004000, "Packing error");

#ifdef __cplusplus
}
#endif

#endif /* CSR_H */

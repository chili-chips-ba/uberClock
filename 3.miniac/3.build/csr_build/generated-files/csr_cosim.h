// ----------------------------------------------------------------------
// Auto-generated by sysrdl_cosim. *** DO NOT EDIT! ***
// Common WireGuard HAL header for both platform and co-simulation
//
// Copyright (C) 2025 Chili.CHIPS*ba
//
// ----------------------------------------------------------------------

#ifndef _CSR_BUILD_GENERATED_FILES_CSR_COSIM_H_ 
#define _CSR_BUILD_GENERATED_FILES_CSR_COSIM_H_

#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif
#include "VUser.h"
#ifdef __cplusplus
}
#endif

#include "csr.h"

// Definitions for co-simulation builds
#define WGMAIN                  VUserMain0
#define NO_DELTA_UPDATE         0

#ifndef SOC_CPU_VPNODE
#define SOC_CPU_VPNODE          0
#endif

#ifndef SOC_CPU_CLK_PERIOD_PS
#define SOC_CPU_CLK_PERIOD_PS   18518
#endif

// -----------------------------------------------------
class imem_vp_t {
public:

    imem_vp_t(uint32_t* base_addr = (uint32_t*)0x0)
    {
    };

} ;

// -----------------------------------------------------
class dmem_vp_t {
public:

    dmem_vp_t(uint32_t* base_addr = (uint32_t*)0x10000000)
    {
    };

} ;

// -----------------------------------------------------
//
class csr__uart__rx_vp_t {
public:
    csr__uart__rx_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     data (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x1, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t data () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__UART__RX__DATA_bm) >> CSR__UART__RX__DATA_bp;
                    };

    inline void     oflow (const uint32_t data) {
                                uint32_t rdata; VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                uint32_t tmpdata = ((uint32_t)rdata << 0) & ~CSR__UART__RX__OFLOW_bm;
                                tmpdata |= ((data << CSR__UART__RX__OFLOW_bp) & CSR__UART__RX__OFLOW_bm) >> 0;
                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);

                                VWriteBE(reg + 0, wdata, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                VTick(rand() % 33, SOC_CPU_VPNODE);
                      };

    inline uint32_t oflow () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__UART__RX__OFLOW_bm) >> CSR__UART__RX__OFLOW_bp;
                    };

    inline void     valid (const uint32_t data) {
                                uint32_t rdata; VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                uint32_t tmpdata = ((uint32_t)rdata << 0) & ~CSR__UART__RX__VALID_bm;
                                tmpdata |= ((data << CSR__UART__RX__VALID_bp) & CSR__UART__RX__VALID_bm) >> 0;
                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);

                                VWriteBE(reg + 0, wdata, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                VTick(rand() % 33, SOC_CPU_VPNODE);
                      };

    inline uint32_t valid () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__UART__RX__VALID_bm) >> CSR__UART__RX__VALID_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__uart__rx_trigger_read_2925067f_vp_t {
public:
    csr__uart__rx_trigger_read_2925067f_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     read (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x1, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t read () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__UART__RX_TRIGGER_READ_2925067F__READ_bm) >> CSR__UART__RX_TRIGGER_READ_2925067F__READ_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__uart__tx_vp_t {
public:
    csr__uart__tx_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     data (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x1, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t data () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__UART__TX__DATA_bm) >> CSR__UART__TX__DATA_bp;
                    };

    inline void     busy (const uint32_t data) {
                                uint32_t rdata; VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                uint32_t tmpdata = ((uint32_t)rdata << 0) & ~CSR__UART__TX__BUSY_bm;
                                tmpdata |= ((data << CSR__UART__TX__BUSY_bp) & CSR__UART__TX__BUSY_bm) >> 0;
                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);

                                VWriteBE(reg + 0, wdata, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                VTick(rand() % 33, SOC_CPU_VPNODE);
                      };

    inline uint32_t busy () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__UART__TX__BUSY_bm) >> CSR__UART__TX__BUSY_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__uart__tx_trigger_write_d2a2fe0e_vp_t {
public:
    csr__uart__tx_trigger_write_d2a2fe0e_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     write (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x1, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t write () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__UART__TX_TRIGGER_WRITE_D2A2FE0E__WRITE_bm) >> CSR__UART__TX_TRIGGER_WRITE_D2A2FE0E__WRITE_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
class csr__uart_vp_t {
public:

    csr__uart_vp_t(uint32_t* base_addr)
    {
        rx = new csr__uart__rx_vp_t (base_addr);
        rx_trigger = new csr__uart__rx_trigger_read_2925067f_vp_t (base_addr +
                                                                                   sizeof(csr__uart__rx_t)/4
                                                                                    );
        tx = new csr__uart__tx_vp_t (base_addr +
                                                                                   sizeof(csr__uart__rx_t)/4 + 
                                                                                   sizeof(csr__uart__rx_trigger_read_2925067f_t)/4
                                                                                    );
        tx_trigger = new csr__uart__tx_trigger_write_d2a2fe0e_vp_t (base_addr +
                                                                                   sizeof(csr__uart__rx_t)/4 + 
                                                                                   sizeof(csr__uart__rx_trigger_read_2925067f_t)/4 + 
                                                                                   sizeof(csr__uart__tx_t)/4
                                                                                    );
    };

    csr__uart__rx_vp_t* rx;
    csr__uart__rx_trigger_read_2925067f_vp_t* rx_trigger;
    csr__uart__tx_vp_t* tx;
    csr__uart__tx_trigger_write_d2a2fe0e_vp_t* tx_trigger;
} ;

// -----------------------------------------------------
//
class csr__gpio_vp_t {
public:
    csr__gpio_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     key1 (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x1, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t key1 () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__GPIO__KEY1_bm) >> CSR__GPIO__KEY1_bp;
                    };

    inline void     key2 (const uint32_t data) {
                                uint32_t rdata; VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                uint32_t tmpdata = ((uint32_t)rdata << 0) & ~CSR__GPIO__KEY2_bm;
                                tmpdata |= ((data << CSR__GPIO__KEY2_bp) & CSR__GPIO__KEY2_bm) >> 0;
                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);

                                VWriteBE(reg + 0, wdata, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                VTick(rand() % 33, SOC_CPU_VPNODE);
                      };

    inline uint32_t key2 () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__GPIO__KEY2_bm) >> CSR__GPIO__KEY2_bp;
                    };

    inline void     led1 (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 8, 0x2, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t led1 () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__GPIO__LED1_bm) >> CSR__GPIO__LED1_bp;
                    };

    inline void     led2 (const uint32_t data) {
                                uint32_t rdata; VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                uint32_t tmpdata = ((uint32_t)rdata << 0) & ~CSR__GPIO__LED2_bm;
                                tmpdata |= ((data << CSR__GPIO__LED2_bp) & CSR__GPIO__LED2_bm) >> 0;
                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);

                                VWriteBE(reg + 0, wdata, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                VTick(rand() % 33, SOC_CPU_VPNODE);
                      };

    inline uint32_t led2 () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__GPIO__LED2_bm) >> CSR__GPIO__LED2_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__hw_id_vp_t {
public:
    csr__hw_id_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     PRODUCT (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x3, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t PRODUCT () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__HW_ID__PRODUCT_bm) >> CSR__HW_ID__PRODUCT_bp;
                    };

    inline void     VENDOR (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 16, 0xc, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t VENDOR () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__HW_ID__VENDOR_bm) >> CSR__HW_ID__VENDOR_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__adc_vp_t {
public:
    csr__adc_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     ch2 (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x3, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t ch2 () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__ADC__CH2_bm) >> CSR__ADC__CH2_bp;
                    };

    inline void     ch1 (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 16, 0xc, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t ch1 () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__ADC__CH1_bm) >> CSR__ADC__CH1_bp;
                    };

    inline void     done (const uint32_t data) {
                                uint32_t rdata; VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                uint32_t tmpdata = ((uint32_t)rdata << 0) & ~CSR__ADC__DONE_bm;
                                tmpdata |= ((data << CSR__ADC__DONE_bp) & CSR__ADC__DONE_bm) >> 0;
                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);

                                VWriteBE(reg + 0, wdata, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                VTick(rand() % 33, SOC_CPU_VPNODE);
                      };

    inline uint32_t done () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__ADC__DONE_bm) >> CSR__ADC__DONE_bp;
                    };

    inline void     start (const uint32_t data) {
                                uint32_t rdata; VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                uint32_t tmpdata = ((uint32_t)rdata << 0) & ~CSR__ADC__START_bm;
                                tmpdata |= ((data << CSR__ADC__START_bp) & CSR__ADC__START_bm) >> 0;
                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);

                                VWriteBE(reg + 0, wdata, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                VTick(rand() % 33, SOC_CPU_VPNODE);
                      };

    inline uint32_t start () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__ADC__START_bm) >> CSR__ADC__START_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__dac_vp_t {
public:
    csr__dac_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     ch2 (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x3, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t ch2 () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__DAC__CH2_bm) >> CSR__DAC__CH2_bp;
                    };

    inline void     ch1 (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 16, 0xc, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t ch1 () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__DAC__CH1_bm) >> CSR__DAC__CH1_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__hw_version_vp_t {
public:
    csr__hw_version_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     PATCH (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x3, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t PATCH () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__HW_VERSION__PATCH_bm) >> CSR__HW_VERSION__PATCH_bp;
                    };

    inline void     MINOR (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 16, 0x4, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t MINOR () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__HW_VERSION__MINOR_bm) >> CSR__HW_VERSION__MINOR_bp;
                    };

    inline void     MAJOR (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 24, 0x8, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t MAJOR () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__HW_VERSION__MAJOR_bm) >> CSR__HW_VERSION__MAJOR_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
class csr__dac_mem_vp_t {
public:

    csr__dac_mem_vp_t(uint32_t* base_addr)
    {
    };

} ;

// -----------------------------------------------------
class csr_vp_t {
public:

    csr_vp_t(uint32_t* base_addr = (uint32_t*)0x20000000)
    {
        uart = new csr__uart_vp_t (base_addr);
        gpio = new csr__gpio_vp_t (base_addr +
                                                                                   sizeof(csr__uart_t)/4
                                                                                    );
        hw_id = new csr__hw_id_vp_t (base_addr +
                                                                                   sizeof(csr__uart_t)/4 + 
                                                                                   sizeof(csr__gpio_t)/4
                                                                                    );
        adc = new csr__adc_vp_t (base_addr +
                                                                                   sizeof(csr__uart_t)/4 + 
                                                                                   sizeof(csr__gpio_t)/4 + 
                                                                                   sizeof(csr__hw_id_t)/4
                                                                                    );
        dac = new csr__dac_vp_t (base_addr +
                                                                                   sizeof(csr__uart_t)/4 + 
                                                                                   sizeof(csr__gpio_t)/4 + 
                                                                                   sizeof(csr__hw_id_t)/4 + 
                                                                                   sizeof(csr__adc_t)/4
                                                                                    );
        hw_version = new csr__hw_version_vp_t (base_addr +
                                                                                   sizeof(csr__uart_t)/4 + 
                                                                                   sizeof(csr__gpio_t)/4 + 
                                                                                   sizeof(csr__hw_id_t)/4 + 
                                                                                   sizeof(csr__adc_t)/4 + 
                                                                                   sizeof(csr__dac_t)/4
                                                                                    );
        dac_mem = new csr__dac_mem_vp_t (base_addr +
                                                                                   sizeof(csr__uart_t)/4 + 
                                                                                   sizeof(csr__gpio_t)/4 + 
                                                                                   sizeof(csr__hw_id_t)/4 + 
                                                                                   sizeof(csr__adc_t)/4 + 
                                                                                   sizeof(csr__dac_t)/4 + 
                                                                                   sizeof(csr__hw_version_t)/4
                                                                                    );
    };

    csr__uart_vp_t* uart;
    csr__gpio_vp_t* gpio;
    csr__hw_id_vp_t* hw_id;
    csr__adc_vp_t* adc;
    csr__dac_vp_t* dac;
    csr__hw_version_vp_t* hw_version;
    csr__dac_mem_vp_t* dac_mem;
} ;


#endif
